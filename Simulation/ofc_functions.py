#from optic.models.devices import mzm, pm
from optic.utils import parameters
import numpy as np

π = np.pi


def pm(Ai, u, Vπ):
    return Ai*np.cos(u/Vπ*np.pi) + 1j*Ai*np.sin(u/Vπ*np.pi)

def mzm(Ai, u, Vπ, Vb):
    return Ai * np.cos(0.5 / Vπ * (u + Vb) * np.pi)

def ddmzm(Ai, u1, u2, Vb1, Vb2, Vπ):
    return 0.5 * Ai * (pm(1, u1 + Vb1, Vπ) + pm(1, u2 + Vb2, Vπ)) 

def frequencyCombGenerator_MZM_MZM_PM(params, Rs, t, P, Vπ):

    '''
    This function generates a frequency comb signal using two MZMs and a PM.
    
    Parameters:
    V1, V2, V3: float
        Amplitude of the signals (V)
    Phase1, Phase2, Phase3: float
        Phase of the signals (rad)
    Vb1, Vb2: float
        Bias voltage of the MZMs (V)

    Returns:
    frequency_comb: array
        Frequency comb signal
    '''
    V1, V2, V3, Phase1, Phase2, Phase3, Vb1, Vb2 = params

    u1 = V1 * np.cos(2 * π * Rs * t + Phase1)
    u2 = V2 * np.cos(2 * π * Rs * t + Phase2)
    u3 = V3 * np.cos(2 * π * Rs * t + Phase3)

    frequency_comb = P
    frequency_comb = mzm(frequency_comb, u1, Vπ, Vb1)
    frequency_comb = mzm(frequency_comb, u2, Vπ, Vb2)
    frequency_comb =  pm(frequency_comb, u3, Vπ)

    return frequency_comb

def frequencyCombGenerator_MZM_MZM_PM_ocp(params, Rs, t, P, Vπ): # Using opticommpy
    ''' 
    This function generates a frequency comb signal using two MZM and one PM.

    Parameters:
    V1, V2, V3: float
        Amplitude of the signals (V)
    Phase1, Phase2, Phase3: float
        Phase of the signals (rad)
    Vb1, Vb2: float
        Bias voltage of the MZM (V)

    Returns:
    frequency_comb: array
        Frequency comb signal
    '''

    V1, V2, V3, Phase1, Phase2, Phase3, Vb1, Vb2 = params
    u1 = V1 * np.cos(2 * π * Rs * t + Phase1)
    u2 = V2 * np.cos(2 * π * Rs * t + Phase2)
    u3 = V3 * np.cos(2 * π * Rs * t + Phase3)

    par1 = parameters()
    par1.Vpi = Vπ
    par1.Vb = Vb1

    par2 = parameters()
    par2.Vpi = Vπ
    par2.Vb = Vb2

    frequency_comb = P
    frequency_comb = mzm(frequency_comb, u1, par1)
    frequency_comb = mzm(frequency_comb, u2, par2)
    frequency_comb =  pm(frequency_comb, u3, Vπ)

    return frequency_comb

def frequencyCombGenerator_DDMZM(params, Rs, t, P, Vπ):
    ''' 
    This function generates a frequency comb using a dual-drive Mach-Zehnder modulator (DD-MZM)

    Parameters:
    V1 : float
        Amplitude of the signal for the first modulator (V)
    V2 : float
        Amplitude of the signal for the second modulator (V)
    Phase1 : float
        Phase of the signal for the first modulator (rad)
    Phase2 : float
        Phase of the signal for the second modulator (rad)
    Vb1 : float
        Bias voltage for the first modulator (V)
    Vb2 : float
        Bias voltage for the second modulator (V)

    Returns:
    frequency_comb : array
        Frequency comb generated by the DDMZM (W)

    '''
    V1, V2, Phase1, Phase2, Vb1, Vb2 = params
    u1 = V1 * np.cos(2 * π * Rs * t + Phase1)
    u2 = V2 * np.cos(2 * π * Rs * t + Phase2)
    
    frequency_comb = ddmzm(P, u1, u2, Vb1, Vb2, Vπ)

    return frequency_comb

def get_psd_ByFFT(signal, Fa, NFFT = 16*1024):
    ''' 
    Function to calculate the Power Spectral Density (PSD) of a signal using the FFT

    Parameters:
    signal: array_like
        Signal to calculate the PSD
    Fa: float
        Sampling frequency of the signal (samples per second)
    NFFT: int
        Number of points of the FFT (default is 16*1024)
        
    Returns:
    psd: array_like
        Power Spectral Density of the signal
    freqs: array_like
        Frequencies of the PSD    
    '''
    
    fft_result = np.fft.fftshift(np.fft.fft(signal, NFFT))
    power_spectrum = np.abs(fft_result)**2
    psd = power_spectrum / (NFFT*Fa)
    freqs = np.fft.fftshift(np.fft.fftfreq(NFFT, 1 / Fa))

    #min_psd = np.min(psd[psd != 0])
    min_psd = 10e-100
    psd[psd == 0] = min_psd
    
    return psd, freqs

def get_indx_peaks(log_Pxx, SpRs, n_peaks):
    '''
    Function to get the indexes of the peaks in the power spectrum of the frequency comb signal

    Parameters:
    log_Pxx: numpy array
        Power spectrum of the frequency comb signal
    SpRs: int
        Samples by each Rs. Each peak is separated by the Rs frequency
    n_peaks: int
        Number of peaks to be found

    Returns:
    indx: list
        Indexes of the peaks in the power spectrum of the frequency comb signal
    '''
    
    center_indx = int(log_Pxx.size//2)
    indx = []
    # Get the indexes of the left peaks
    for i in range(n_peaks//2, 0, -1):
        indx.append(int(center_indx - i*SpRs)) 

    indx.append(center_indx) #append the center peak

    # Get the indexes of the right peaks
    for i in range(1, n_peaks//2 + 1):
        indx.append(int(center_indx + i*SpRs))

    return indx