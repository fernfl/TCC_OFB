#from optic.models.devices import mzm, pm
from optic.utils import parameters
import numpy as np
import torch.distributions.uniform as urand
from scipy.optimize import minimize

π = np.pi

class parameters():
    pass

def pm(Ai, u, Vπ):
    return Ai*np.cos(u/Vπ*np.pi) + 1j*Ai*np.sin(u/Vπ*np.pi)

def mzm(Ai, u, Vπ, Vb):
    return Ai * np.cos(0.5 / Vπ * (u + Vb) * np.pi)

def ddmzm(Ai, u1, u2, Vb1, Vb2, Vπ):
    return 0.5 * Ai * (pm(1, u1 + Vb1, Vπ) + pm(1, u2 + Vb2, Vπ)) 

def frequencyCombGenerator_MZM_MZM_PM(params, Rs, t, P, Vπ):

    '''
    This function generates a frequency comb signal using two MZMs and a PM.
    
    Parameters:
    V1, V2, V3: float
        Amplitude of the signals (V)
    Phase1, Phase2, Phase3: float
        Phase of the signals (rad)
    Vb1, Vb2: float
        Bias voltage of the MZMs (V)

    Returns:
    frequency_comb: array
        Frequency comb signal
    '''
    V1, V2, V3, Phase1, Phase2, Phase3, Vb1, Vb2 = params

    u1 = V1 * np.cos(2 * π * Rs * t + Phase1)
    u2 = V2 * np.cos(2 * π * Rs * t + Phase2)
    u3 = V3 * np.cos(2 * π * Rs * t + Phase3)

    frequency_comb = P
    frequency_comb = mzm(frequency_comb, u1, Vπ, Vb1)
    frequency_comb = mzm(frequency_comb, u2, Vπ, Vb2)
    frequency_comb =  pm(frequency_comb, u3, Vπ)

    return frequency_comb

def frequencyCombGenerator_PM_PM_MZM(params, Rs, t, P, Vπ):

    '''
    This function generates a frequency comb signal using two MZMs and a PM.
    
    Parameters:
    V1, V2, V3: float
        Amplitude of the signals (V)
    Phase1, Phase2, Phase3: float
        Phase of the signals (rad)
    Vb1, Vb2: float
        Bias voltage of the MZMs (V)

    Returns:
    frequency_comb: array
        Frequency comb signal
    '''
    V1, V2, V3, Phase1, Phase2, Phase3, Vb1 = params

    u1 = V1 * np.cos(2 * π * Rs * t + Phase1)
    u2 = V2 * np.cos(2 * π * Rs * t + Phase2)
    u3 = V3 * np.cos(2 * π * Rs * t + Phase3)

    frequency_comb = P
    frequency_comb =  pm(frequency_comb, u1, Vπ)
    frequency_comb =  pm(frequency_comb, u2, Vπ)
    frequency_comb = mzm(frequency_comb, u3, Vπ, Vb1)

    return frequency_comb

def frequencyCombGenerator_MZM_MZM_PM_ocp(params, Rs, t, P, Vπ): # Using opticommpy
    ''' 
    This function generates a frequency comb signal using two MZM and one PM.

    Parameters:
    V1, V2, V3: float
        Amplitude of the signals (V)
    Phase1, Phase2, Phase3: float
        Phase of the signals (rad)
    Vb1, Vb2: float
        Bias voltage of the MZM (V)

    Returns:
    frequency_comb: array
        Frequency comb signal
    '''

    V1, V2, V3, Phase1, Phase2, Phase3, Vb1, Vb2 = params
    u1 = V1 * np.cos(2 * π * Rs * t + Phase1)
    u2 = V2 * np.cos(2 * π * Rs * t + Phase2)
    u3 = V3 * np.cos(2 * π * Rs * t + Phase3)

    par1 = parameters()
    par1.Vpi = Vπ
    par1.Vb = Vb1

    par2 = parameters()
    par2.Vpi = Vπ
    par2.Vb = Vb2

    frequency_comb = P
    frequency_comb = mzm(frequency_comb, u1, par1)
    frequency_comb = mzm(frequency_comb, u2, par2)
    frequency_comb =  pm(frequency_comb, u3, Vπ)

    return frequency_comb

def frequencyCombGenerator_DDMZM(params, Rs, t, P, Vπ):
    ''' 
    This function generates a frequency comb using a dual-drive Mach-Zehnder modulator (DD-MZM)

    Parameters:
    V1 : float
        Amplitude of the signal for the first modulator (V)
    V2 : float
        Amplitude of the signal for the second modulator (V)
    Phase1 : float
        Phase of the signal for the first modulator (rad)
    Phase2 : float
        Phase of the signal for the second modulator (rad)
    Vb1 : float
        Bias voltage for the first modulator (V)
    Vb2 : float
        Bias voltage for the second modulator (V)

    Returns:
    frequency_comb : array
        Frequency comb generated by the DDMZM (W)

    '''
    V1, V2, Phase1, Phase2, Vb1, Vb2 = params
    u1 = V1 * np.cos(2 * π * Rs * t + Phase1)
    u2 = V2 * np.cos(2 * π * Rs * t + Phase2)
    
    frequency_comb = ddmzm(P, u1, u2, Vb1, Vb2, Vπ)

    return frequency_comb

def get_psd_ByFFT(signal, Fa, NFFT = 16*1024):
    ''' 
    Function to calculate the Power Spectral Density (PSD) of a signal using the FFT

    Parameters:
    signal: array_like
        Signal to calculate the PSD
    Fa: float
        Sampling frequency of the signal (samples per second)
    NFFT: int
        Number of points of the FFT (default is 16*1024)
        
    Returns:
    psd: array_like
        Power Spectral Density of the signal
    freqs: array_like
        Frequencies of the PSD    
    '''
    
    fft_result = np.fft.fftshift(np.fft.fft(signal, NFFT))
    power_spectrum = np.abs(fft_result)**2
    psd = power_spectrum / (NFFT*Fa)
    freqs = np.fft.fftshift(np.fft.fftfreq(NFFT, 1 / Fa))

    #min_psd = np.min(psd[psd != 0])
    min_psd = 10e-100
    psd[psd == 0] = min_psd
    
    return psd, freqs

def get_indx_peaks(log_Pxx, SpRs, n_peaks):
    '''
    Function to get the indexes of the peaks in the power spectrum of the frequency comb signal

    Parameters:
    log_Pxx: numpy array
        Power spectrum of the frequency comb signal
    SpRs: int
        Samples by each Rs. Each peak is separated by the Rs frequency. SpRs = (NFFT/SpS)
    n_peaks: int
        Number of peaks to be found

    Returns:
    indx: list
        Indexes of the peaks in the power spectrum of the frequency comb signal
    '''
    
    center_indx = int(log_Pxx.size//2)
    indx = []
    # Get the indexes of the left peaks
    for i in range(n_peaks//2, 0, -1):
        indx.append(int(center_indx - i*SpRs)) 

    indx.append(center_indx) #append the center peak

    # Get the indexes of the right peaks
    for i in range(1, n_peaks//2 + 1):
        indx.append(int(center_indx + i*SpRs))

    return indx

def frequencyCombPeaks(params, args):
    ''' 
    Function to get the peaks of the power spectrum of the frequency comb signal

    Parameters:
    params: list
        Parameters to generate the frequency comb signal
    args: parameters
        Parameters object with the arguments to generate the frequency comb signal
        Should contain the following attributes: Rs, t, P, Vπ, Fa, NFFT, SpS, n_peaks

    Returns:
    peaks: list
        Peaks of the power spectrum of the frequency comb signal
    '''

    #frequency_comb = frequencyCombGenerator_MZM_MZM_PM(params, args.Rs, args.t, args.P, args.Vpi) # Generate the frequency comb signal
    frequency_comb = frequencyCombGenerator_PM_PM_MZM(params, args.Rs, args.t, args.P, args.Vpi) # Generate the frequency comb signal
    Pxx, _ = get_psd_ByFFT(frequency_comb, args.Fa, args.NFFT) # Get the power spectrum of the frequency comb signal
    log_Pxx = 10*np.log10(Pxx) # Convert the power spectrum to dB
    indx = get_indx_peaks(log_Pxx, args.NFFT/args.SpS, args.n_peaks) # Get the indexes of the peaks

    peaks = log_Pxx[indx].tolist() # Get the peaks of the power spectrum
    return peaks


def optimization_flatComb(initial_guess, args, bounds, n_max = 100, method = "SLSQP"):
    ''' 
    Function to optimize the parameters of the frequency comb signal

    Parameters:
    initial_guess: list
        Initial guess for the parameters of the frequency comb signal
    args: parameters()
        Parameters object with the arguments to generate the frequency comb signal
        Should contain the following attributes: Rs, t, P, Vpi, Fa, NFFT, SpS, n_peaks
    bounds: list
        Bounds of the parameters
    n_max: int
        Max number of iterations
    method: string
        Optimization method

    Returns:
    optimized_params: list
        Optimized parameters of the frequency comb signal
    '''

    def objective_function(params, *args):

        peaks = frequencyCombPeaks(params, *args)
        var = np.var(peaks)
        
        return var**2
    
    optimized_params = initial_guess
    n = 0
    while n < n_max:
        initial_guess = optimized_params
        result = minimize(objective_function, initial_guess, args = args, method=method, bounds = bounds)
        optimized_params = result.x
        
        peaks = frequencyCombPeaks(optimized_params, args)
        min_max = np.max(peaks) - np.min(peaks)

        if min_max < 1:
            break
        n += 1

    return optimized_params, peaks, min_max


def create_flatCombs(nsamples, args, bounds, upper_min_max = 5.0):
    '''
    Function to create the flatComb datasets

    Parameters:
    nsamples: int
        Number of samples to be created
    bounds: list
        Bounds of the parameters
    upper_min_max: float
        Maximum value of the peaks variance

    Returns:
    flatComb_inputs0_1dB: list
        Inputs of the flatComb dataset with peaks variance less than 1 dB
    flatComb_outputs0_1dB: list
        Outputs of the flatComb dataset with peaks variance less than 1 dB
    flatComb_inputs1_ndB: list
        Inputs of the flatComb dataset with peaks variance between 1 and n dB, where n is the upper_min_max
    flatComb_outputs1_ndB: list
        Outputs of the flatComb dataset with peaks variance between 1 and n dB, where n is the upper_min_max
        
    '''
    #inputs = FrequencyCombDataset.make_inputs(FrequencyCombDataset, bounds = bounds, nsamples = 10)
    inputs = [[urand.Uniform(low, high).sample().item() for low, high in bounds] for _ in range(nsamples)]

    flatComb_inputs0_1dB = []
    flatComb_outputs0_1dB = []

    flatComb_inputs1_ndB = []
    flatComb_outputs1_ndB = []
    for input in inputs:
        best_params, peaks, min_max = optimization_flatComb(input, args, bounds, n_max = 5)
        if min_max < 1:
            flatComb_inputs0_1dB.append(best_params)
            peaks = peaks - np.mean(peaks)
            flatComb_outputs0_1dB.append(peaks)
        elif min_max < upper_min_max:
            flatComb_inputs1_ndB.append(best_params)
            peaks = peaks - np.mean(peaks)
            flatComb_outputs1_ndB.append(peaks)

    flatComb_inputs0_1dB = np.array(flatComb_inputs0_1dB)
    flatComb_outputs0_1dB = np.array(flatComb_outputs0_1dB)

    flatComb_inputs1_ndB = np.array(flatComb_inputs1_ndB)
    flatComb_outputs1_ndB = np.array(flatComb_outputs1_ndB)

    return flatComb_inputs0_1dB, flatComb_outputs0_1dB, flatComb_inputs1_ndB, flatComb_outputs1_ndB
